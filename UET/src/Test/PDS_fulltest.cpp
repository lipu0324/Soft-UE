/*******************************************************************************
 * Copyright 2025 Soft UE Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

/**
 * @file             PDS_fulltest.cpp
 * @brief            PDS_fulltest.cpp
 * @author           softuegroup@gmail.com
 * @version          1.0.0
 * @date             2025-10-29
 * @copyright        Apache License Version 2.0
 *
 * @details
 * PDS_fulltest.cpp
 */



#include "../PDS/PDS_Manager/PDSManager.hpp"
#include "../logger/Logger.hpp"
#include <thread>
#include <chrono>
#include <iostream>

// ==================== Modular Function Definitions ====================

/**
 * @brief Generate SES_PDS_req test data (modular version)
 * @param req Reference to SES_PDS_req structure to be filled
 * @param src_fep Source FEP address
 * @param dst_fep Destination FEP address
 * @param msg_id Message ID
 * @param job_id Job ID
 * @param is_connection_init Whether it's a connection initialization packet
 */
void req_gen_module(SES_PDS_req& req, uint32_t src_fep = 0x12345678, 
                   uint32_t dst_fep = 0x87654321, uint16_t msg_id = 0x0001,
                   uint32_t job_id = 0x00000001, bool is_connection_init = false, bool is_eom = false)
{
    req.src_fep = src_fep;
    req.dst_fep = dst_fep;
    req.mode = ROD;
    req.rod_context = 0x0001;
    req.next_hdr = PDS_next_hdr::UET_HDR_REQUEST_STD;
    req.tc = 0x01;
    req.lock_pdc = true;
    req.tx_pkt_handle = 0x0001;
    req.pkt_len = 100;
    req.tss_context = 0x0001;
    req.rsv_pdc_context = 0x0001;
    req.rsv_ccc_context = 0x0001;
    
    req.pkt.bth_type = SES_BTH_header_type::Standard_Header;
    req.pkt.bth_header.Standard_Header.rsvd = 0;
    req.pkt.bth_header.Standard_Header.opcode = 0;
    req.pkt.bth_header.Standard_Header.version = 0;
    req.pkt.bth_header.Standard_Header.ie = 0;
    req.pkt.bth_header.Standard_Header.rel = 0;
    req.pkt.bth_header.Standard_Header.hd = 0;
    req.pkt.bth_header.Standard_Header.eom = is_eom ? 1 : 0;
    req.pkt.bth_header.Standard_Header.som = is_connection_init ? 1 : 0;
    req.pkt.bth_header.Standard_Header.msg_id = msg_id;
    req.pkt.bth_header.Standard_Header.ri_generation = 0x00;
    req.pkt.bth_header.Standard_Header.job_id = job_id;
    req.pkt.bth_header.Standard_Header.PIDonFEP = 0x0001;
    req.pkt.bth_header.Standard_Header.rsvd0 = 0x00;
    req.pkt.bth_header.Standard_Header.resource_index = 0x0001;
    req.pkt.bth_header.Standard_Header.buffer_offset = 0x0000000000000001;
    req.pkt.bth_header.Standard_Header.initiator = 0x00000001;
    req.pkt.bth_header.Standard_Header.match_bits = 0x0000000000000001;
    
}

/**
 * @brief Simulate network layer transferring packets generated by PDC
 * @param pds_manager Reference to PDS manager
 * @param max_packets Maximum number of packets to transfer
 * @return Actual number of packets transferred
 *
 * This function simulates network layer behavior: retrieves packets sent by IPDC from PDStoNet queue,
 * then puts them into Net_rx_pkt_q queue, simulating arrival at TPDC after network transmission
 */
int simulate_network_transfer(PDS_Manager& pds_manager, int max_packets = 10)
{
    int transferred = 0;
    PDStoNET_pkt pkt;
    
    // Retrieve packets from PDStoNet queue, simulating network layer reception
    while (transferred < max_packets && pds_manager.PDStoNet.pop(pkt)) {
        // Put packets into Net_rx_pkt_q queue, simulating arrival at peer after network transmission
        pds_manager.Net_rx_pkt_q.push(pkt);
        transferred++;
        uint16_t spdcid;
        if(pkt.PDS_type == RUOD_req_header)spdcid = pkt.PDS_header.RUOD_req_header.spdcid;
        else if(pkt.PDS_type == RUOD_cp_header)spdcid = pkt.PDS_header.RUOD_cp_header.spdcid;
        else if(pkt.PDS_type == RUOD_ack_header)spdcid = pkt.PDS_header.RUOD_ack_header.spdcid;
        else spdcid = pkt.PDS_header.nack_header.spdcid;

        uint16_t dpdcid;
        if(pkt.PDS_type == RUOD_req_header)dpdcid = pkt.PDS_header.RUOD_req_header.dpdcid;
        else if(pkt.PDS_type == RUOD_cp_header)dpdcid = pkt.PDS_header.RUOD_cp_header.dpdcid;
        else if(pkt.PDS_type == RUOD_ack_header)dpdcid = pkt.PDS_header.RUOD_ack_header.dpdcid;
        else dpdcid = pkt.PDS_header.nack_header.dpdcid;

        LOG_DEBUG("simulate_network_transfer",
                 "Transferred packet " + std::to_string(transferred) +
                 ": src_fep=" + std::to_string(pkt.src_fep) +
                 ", dst_fep=" + std::to_string(pkt.dst_fep) +
                 ", PDS_type=" + std::to_string(pkt.PDS_type) +
                 ", SPDCID=" + std::to_string(spdcid) +
                 ", DPDCID=" + std::to_string(dpdcid));
    }
    
    return transferred;
}

/**
 * @brief Find the first opened PDC
 * @param pds_manager Reference to PDS manager
 * @param start_index Index to start searching from
 * @param is_ipdc Whether it's IPDC (true for IPDC, false for TPDC)
 * @return Found PDCID, return -1 if not found
 */
int16_t find_opened_pdc(PDS_Manager& pds_manager, bool *pdc_statements, size_t pdc_count)
{
    for (uint16_t i = 0; i < pdc_count; i++) {
        if (pds_manager.pdc_list[i].is_open && !pdc_statements[i]) {
            pdc_statements[i] = true;
            return i;
        }
    }
    return -1;
}

/**
 * @brief Establish complete IPDC-TPDC connection pair
 * @param pds_manager Reference to PDS manager
 * @param src_fep Source FEP address
 * @param dst_fep Target FEP address
 * @param msg_id Message ID
 * @param job_id Job ID
 * @param ipdc_id Output parameter: established IPDC ID
 * @param tpdc_id Output parameter: established TPDC ID
 * @return Whether connection was successfully established
 */
bool establish_pdc_connection(PDS_Manager& pds_manager,
                              uint32_t src_fep, uint32_t dst_fep,
                              uint16_t msg_id, uint32_t job_id,
                              int16_t& ipdc_id, int16_t& tpdc_id,
                              bool *pdc_statements, size_t pdc_count)
{
    LOG_INFO("establish_pdc_connection",
            "Starting to establish connection - src_fep: " + std::to_string(src_fep) +
            ", dst_fep: " + std::to_string(dst_fep) +
            ", msg_id: " + std::to_string(msg_id) +
            ", job_id: " + std::to_string(job_id));
    // 1. Create SES connection request
    SES_PDS_req connection_req;
    req_gen_module(connection_req, src_fep, dst_fep, msg_id, job_id, true, true);
    
    // 2. Send request to PDS
    pds_manager.SES_tx_req_q.push(connection_req);
    pds_manager.mainChk();
    std::this_thread::sleep_for(std::chrono::milliseconds(100));

    // 3. Simulate network layer transferring SYN packet sent by IPDC to TPDC
    if (simulate_network_transfer(pds_manager, 1) == 0) {
        LOG_ERROR("establish_pdc_connection", "Failed to get SYN packet from IPDC");
        return false;
    }
    else{
        ipdc_id = find_opened_pdc(pds_manager, pdc_statements, pdc_count);
        if(ipdc_id == -1){
            LOG_ERROR("establish_pdc_connection", "Failed to find established IPDC");
            return false;
        }
    }

    // 4. Process network layer received packets, establish TPDC
    pds_manager.mainChk();
    std::this_thread::sleep_for(std::chrono::milliseconds(100));

    // 5. Simulate network layer transferring SYN-ACK packet sent by TPDC back to IPDC
    if (simulate_network_transfer(pds_manager, 1) == 0) {
        LOG_ERROR("establish_pdc_connection", "Failed to get SYN-ACK packet from TPDC");
        return false;
    }
        else{
        tpdc_id = find_opened_pdc(pds_manager, pdc_statements, pdc_count);
        if(tpdc_id == -1){
            LOG_ERROR("establish_pdc_connection", "Failed to find established TPDC");
            return false;
        }
    }

    // 6. Process SYN-ACK packet, complete IPDC connection establishment
    pds_manager.mainChk();
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    
    if (ipdc_id == -1 || tpdc_id == -1) {
        LOG_ERROR("establish_pdc_connection", "Failed to find established PDC");
        return false;
    }

    LOG_INFO("establish_pdc_connection",
            "Successfully established connection - IPDC: " + std::to_string(ipdc_id) +
            ", TPDC: " + std::to_string(tpdc_id));
    
    return true;
}


/**
 * @brief Print PDC status information
 * @param pds_manager Reference to PDS manager
 * @param ipdc_id IPDC ID
 * @param tpdc_id TPDC ID
 */
void print_pdc_status(PDS_Manager& pds_manager, uint16_t ipdc_id, uint16_t tpdc_id)
{
    auto ipdc_state = pds_manager.IPDC_Processmanager.getPDCState(ipdc_id);
    auto tpdc_state = pds_manager.TPDC_Processmanager.getPDCState(tpdc_id);
    
    LOG_INFO(__FUNCTION__, "IPDC state: " + std::to_string(static_cast<int>(ipdc_state)) +
            ", TPDC state: " + std::to_string(static_cast<int>(tpdc_state)));

    if (ipdc_state == pdc_state::ESTABLISHED && tpdc_state == pdc_state::ESTABLISHED) {
        LOG_INFO(__FUNCTION__, "PDC both sides connection established");
    } else {
        LOG_INFO(__FUNCTION__, "PDC connection not fully established");
    }
}

// ==================== Main Test Function ====================

int main()
{
    Logger::initialize("PDS_fulltest.log", LogLevel::DEBUG, 1, 1);
    PDS_Manager pds_manager;
    
    LOG_INFO(__FUNCTION__, "===================== PDS Full Test Start =====================");

    // 1. Initialize PDS manager
    if (!pds_manager.initPDSM()) {
        LOG_ERROR(__FUNCTION__, "PDS manager initialization failed");
        return -1;
    }
    LOG_INFO(__FUNCTION__, "PDS manager initialized successfully");
    
    bool pdc_statements[MAX_PDC * 2] = {false};

    // 2. Establish initial IPDC-TPDC connection
    int16_t ipdc_id, tpdc_id;
    if (!establish_pdc_connection(pds_manager, 0x12345678, 0x87654321,
                                   0x0001, 0x00000001, ipdc_id, tpdc_id,
                                   pdc_statements, MAX_PDC * 2)) {
        LOG_ERROR(__FUNCTION__, "Failed to establish IPDC-TPDC connection");
        return -1;
    }

    LOG_INFO(__FUNCTION__, "✓ Successfully established initial connection - IPDC: " + std::to_string(ipdc_id) +
            ", TPDC: " + std::to_string(tpdc_id));

    // 3. Verify connection status
    print_pdc_status(pds_manager, ipdc_id, tpdc_id);
    
    // 4. Perform multiple normal data transmission tests
    LOG_INFO(__FUNCTION__, "===================== Start Data Transmission Test =====================");

    const int NUM_TEST_PACKETS = 5;
    for (int i = 0; i < NUM_TEST_PACKETS; i++) {
        // Generate normal data request
        SES_PDS_req data_req;
        req_gen_module(data_req, 0x12345678, 0x87654321, 0x1000 + i, 0x00000001, false, false);
        
        pds_manager.SES_tx_req_q.push(data_req);
        LOG_INFO(__FUNCTION__, "Sent " + std::to_string(i+1) + "th data request");

        pds_manager.mainChk();
        std::this_thread::sleep_for(std::chrono::milliseconds(50));

        // Simulate network layer transfer: IPDC -> TPDC
        int transferred = simulate_network_transfer(pds_manager, 5);
        LOG_DEBUG(__FUNCTION__, "Network layer transferred " + std::to_string(transferred) + " packets");

        for(int j = 0; j < transferred; j++)pds_manager.mainChk();
        std::this_thread::sleep_for(std::chrono::milliseconds(50));

        // Simulate network layer transfer: TPDC -> IPDC (ACK packets)
        transferred = simulate_network_transfer(pds_manager, 5);
        LOG_DEBUG(__FUNCTION__, "Network layer transferred " + std::to_string(transferred) + " ACK packets");
        
        for(int j = 0; j < transferred; j++)pds_manager.mainChk();
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }
    
    LOG_INFO(__FUNCTION__, "✓ Data transmission test completed, sent " + std::to_string(NUM_TEST_PACKETS) + " data packets in total");

    // 5. Verify connection status is still normal
    print_pdc_status(pds_manager, ipdc_id, tpdc_id);
    
    // 6. Test resource_check functionality
    LOG_INFO(__FUNCTION__, "===================== Test resource_check Functionality (Close_Thresh=" + std::to_string(Close_Thresh) + ") =====================");

    // Record number of opened PDCs before creation
    int initial_open_count = 0;
    for (int i = 0; i < MAX_PDC * 2; i++) {
        if (pds_manager.pdc_list[i].is_open) {
            initial_open_count++;
        }
    }
    LOG_INFO(__FUNCTION__, "Number of opened PDCs before creation: " + std::to_string(initial_open_count));
    LOG_INFO(__FUNCTION__, "Close_Thresh=" + std::to_string(Close_Thresh) + ", need to create more than " + std::to_string(Close_Thresh / 2) + " complete IPDC-TPDC connection pairs to trigger resource_check");

    // Count currently opened PDCs
    int opened_count = 2;

    // Create complete IPDC-TPDC connection pairs to trigger resource_check
    const int TARGET_CONNECTION_PAIRS = Close_Thresh / 2;
    int created_pairs = 1; // Already have initial connection
    
    std::vector<std::pair<int16_t, int16_t>> connection_pairs;
    connection_pairs.push_back({ipdc_id, tpdc_id}); // Save initial connection

    for (int i = 0; i < TARGET_CONNECTION_PAIRS && created_pairs <= TARGET_CONNECTION_PAIRS; i++) {
        try {
            int16_t new_ipdc_id, new_tpdc_id;

            // Establish complete IPDC-TPDC connection pair
            if (establish_pdc_connection(pds_manager,
                                        0x12345678,
                                        0x87654321,
                                        0x2000 + i,
                                        0x00001002 + i * 3,
                                        new_ipdc_id, new_tpdc_id,
                                        pdc_statements, MAX_PDC * 2)) {
                connection_pairs.push_back({new_ipdc_id, new_tpdc_id});
                created_pairs++;
                opened_count += 2;
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
                LOG_INFO(__FUNCTION__, "✓ 创建连接对 " + std::to_string(created_pairs) +
                        ": IPDC=" + std::to_string(new_ipdc_id) +
                        ", TPDC=" + std::to_string(new_tpdc_id));
            } else {
                LOG_WARN(__FUNCTION__, "✗ 创建连接对失败");
                break;
            }
            
        } catch (const std::bad_alloc& e) {
            LOG_ERROR(__FUNCTION__, "内存分配错误，停止创建更多连接: " + std::string(e.what()));
            break;
        } catch (const std::exception& e) {
            LOG_ERROR(__FUNCTION__, "创建连接时发生异常: " + std::string(e.what()));
            break;
        }
    }
    
    LOG_INFO(__FUNCTION__, "Current number of opened PDCs: " + std::to_string(opened_count) +
            " (including " + std::to_string(created_pairs) + " complete connection pairs)");

    // Spontaneous work, process all queues
    while(!pds_manager.SES_tx_req_q.empty() || !pds_manager.SES_tx_rsp_q.empty() || !pds_manager.Net_rx_pkt_q.empty()
    || !pds_manager.PDC_close_q.empty() || !pds_manager.PDStoNet.empty()){
        // Simulate network layer transfer: IPDC -> TPDC
        int transferred = simulate_network_transfer(pds_manager, 5);
        LOG_DEBUG(__FUNCTION__, "Queue loop work: network layer transferred " + std::to_string(transferred) + " packets");
        LOG_DEBUG(__FUNCTION__, "Calling mainChk");
        pds_manager.mainChk();
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    
    // Record PDC status after closure
    std::vector<uint16_t> open_pdcs_after;
    for (int i = 0; i < MAX_PDC * 2; i++) {
        if (pds_manager.pdc_list[i].is_open) {
            open_pdcs_after.push_back(i);
        }
    }
    LOG_INFO(__FUNCTION__, "Number of opened PDCs after closure: " + std::to_string(open_pdcs_after.size()));

    // 8. Verify at least one PDC was closed
    if (open_pdcs_after.size() < opened_count) {
        LOG_INFO(__FUNCTION__, "Test successful: resource_check closed " +
                std::to_string(opened_count - open_pdcs_after.size()) + " PDC connections");

        // Find closed PDCs
        std::vector<uint16_t> closed_pdcs;
        for (uint16_t id : open_pdcs_after) {
            if (std::find(open_pdcs_after.begin(), open_pdcs_after.end(), id) == open_pdcs_after.end()) {
                closed_pdcs.push_back(id);
            }
        }

        LOG_INFO(__FUNCTION__, "Closed PDC IDs: ");
        for (uint16_t id : closed_pdcs) {
            LOG_INFO(__FUNCTION__, "  - PDC " + std::to_string(id));
        }
    } else if (open_pdcs_after.size() == opened_count) {
        LOG_WARN(__FUNCTION__, "Test result: No PDC was closed, current number of opened PDCs remains unchanged");
        LOG_INFO(__FUNCTION__, "May need more PDC connections to trigger resource_check mechanism");
    } else {
        LOG_ERROR(__FUNCTION__, "Test anomaly: Number of PDCs increased after closure");
    }

    // 9. Stop PDC process managers
    pds_manager.TPDC_Processmanager.stop();
    pds_manager.IPDC_Processmanager.stop();
    
    LOG_INFO(__FUNCTION__, "===================== PDS Full Test Complete =====================");
    LOG_INFO(__FUNCTION__, "Test Summary:");
    LOG_INFO(__FUNCTION__, "- Successfully established IPDC and TPDC connections");
    LOG_INFO(__FUNCTION__, "- Completed " + std::to_string(NUM_TEST_PACKETS) + " data transmissions");
    LOG_INFO(__FUNCTION__, "- Successfully closed PDC connections through resource_check function");
    LOG_INFO(__FUNCTION__, "- All test steps executed successfully");

    /*
    if (!pds_manager.initPDSM()) {
        LOG_ERROR(__FUNCTION__, "PDS管理器初始化失败");
        return -1;
    }
    LOG_INFO(__FUNCTION__, "PDS管理器初始化成功");
   for(int i=0;i<100;i++){
        // 1. 创建SES连接请求
        SES_PDS_req connection_req;
        req_gen_module(connection_req, i+123456, i+987654321, i, i, true);
    
        // 2. 发送请求到PDS
        pds_manager.SES_tx_req_q.push(connection_req);
        pds_manager.mainChk();
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
   }
    std::this_thread::sleep_for(std::chrono::seconds(5));
    pds_manager.TPDC_Processmanager.stop();
    pds_manager.IPDC_Processmanager.stop();
    */
   /*
   IPDC_ProcessManager test;
   test.start();
    for(int i=0;i<10;i++){
        test.createIPDCProcess(i,i+123456,i+98765432);
    }
    std::this_thread::sleep_for(std::chrono::seconds(5));
    test.stop();
    */
    return 0;
}